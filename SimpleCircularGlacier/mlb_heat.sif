!---LUA BEGIN
! assert(loadfile('./icematerial.lua'))()
! assert(loadfile('./accumulation.lua'))()
!---LUA END


! check keywords warn
! echo on
!!!!!!!!!!!!!!!!!!!!!!!!!
! DEFINITIONS used in run
!!!!!!!!!!!!!!!!!!!!!!!!!!
$name="Circle1_trans"
include defs.sif
$directmethod="mumps" !cPardiso"

$Tc = -1.0


!number of timesteps/year
#nt=10
!dt
#dt = 1/nt
!number of years
#ny=60000

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! HEADER
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Partitioned mesh
Header
  Mesh DB "." "circle"
  Results Directory "results"
End

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CONSTANTS
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Constants
End


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! SIMULATION
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Simulation
  Coordinate System  = "Cartesian 3D"
  Simulation Type = "Transient"


  Timestepping Method = "bdf"
  BDF Order = 1
  Timestep Intervals(1) = #nt*ny
  Output Intervals(1) = 100
  Timestep Sizes(1) = #dt



  ! Internal extrusion parameters, may be altered.
  Extruded Mesh Levels = Integer 9 
  Extruded Max Coordinate = Real 2000		

  ! Coupled iterations between different solvers
  !---------------------------------------------
  Steady State Max Iterations = 10
  Steady State Min Iterations = 1

  ! usually, Dirichlet BC's are initialized before everything else. Sometimes those 
  ! conditions are dependent on solutions of earlier solvers; next line ensures that
  ! this is not an issue.
  !-----------------------------------------
  Initialize Dirichlet Conditions = Logical False
  
  ! Output files
  ! ------------
  Post File = $name$.vtu
  vtu: Save Bulk Only = Logical False

  Scalars File = $name$.dat
  scalars: Parallel Reduce = Logical True

  Output File = $name$.result



  ! how verbose the solver should be
  !  3 = Only warnings
  ! 32 = Maximum verbosity
  !-------------------------------------------------------
  Max Output Level = 3
End


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! BODIES (i.e., domains to compute on)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Body 1
  Name = "glacier"
  Equation = 1
  Material = 1
  Body Force = 1
  Initial Condition = 1
End

Body 2
  Name = "surface"
  Equation = 2
  Material = 2
  Body Force = 2
  Initial Condition = 2
End

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! INITIAL CONDITIONS
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Initial Condition 1
  ! Initial velocity is not really needed when using newtonian start

  Velocity 1 = 0.0
  Velocity 2 = 0.0
  Velocity 3 = 0.0
  Temperature = Variable "Coordinate"
     Real LUA "surfaceT(tx[0], tx[1])"

End

Initial Condition 2
  Zs = Variable "Coordinate"
    Real LUA "Hinit(tx[0], tx[1])"
End


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! BODY FORCE
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Body Force 1
  Flow BodyForce 1 = 0.0
  Flow BodyForce 2 = 0.0 
  Flow BodyForce 3 = $gravity
  Temperature Upper Limit = Real 273.15

  
  Relative Temperature = Variable Temperature
    Real LUA "tx[0] - 273.15"
  Temperature Volume Source = Equals W

End

Body Force 2
  Name = "MB"
  Zs Accumulation Flux 1 = Real 0.0
  Zs Accumulation Flux 2 = Real 0.0
  Zs Accumulation Flux 3 = Variable "Coordinate"
   Real LUA "acc(tx[0], tx[1])"
End



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! MATERIAL
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Material 1
  Name = "Ice"
  Density = Real $rhoi

  Viscosity Model = String "Glen"
  Viscosity = Real 1.0
  Glen Exponent = Real 3.0
  Critical Shear Rate =  Real 1.0E-10

  Limit Temperature = Real -10.0
  Rate Factor 1 = Real $A1 
  Rate Factor 2 = Real $A2 
  Activation Energy 1 = Real $Q1    
  Activation Energy 2 = Real $Q2 
  Glen Enhancement Factor = Real 1.0

  Relative Temperature = Variable Temperature
     Real LUA "tx[0] - 273.15"
  Heat Capacity = Real 2.0E18
  Heat Conductivity = Real 30.0

  Temperature Upper Limit = Real 273.15 
  Temperature Lower Limit = Real 0.0
End



Material 2
  Name = "SMB"
  Min Zs = Real $MinH
End

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! SOLVER
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Solver 1
  Exec Solver = "before Timestep"
  Equation = "MapCoordinate"
  Procedure = "StructuredMeshMapper" "StructuredMeshMapper"

  Active Coordinate = Integer 3

  Displacement Mode = Logical False
  Correct Surface = Logical True

  Minimum Height = Real $MinH

  Correct Surface Mask = String "Glaciated"
  Dot Product Tolerance = 1.0e-3

  variable = MeshUpdate

End

Solver 2
  Exec Solver = "before Timestep"
  Equation = "HeightDepth"
  Procedure = "StructuredProjectToPlane" "StructuredProjectToPlane"
  Active Coordinate = Integer 3
  Operator 1 = depth
  Operator 2 = height
End 

Solver 3
  Equation = "Stokes-Vec"
  Procedure = "IncompressibleNSVec" "IncompressibleNSSolver"
  Div-Curl Discretization = Logical False

  Optimize Bandwidth = Logical True
  Flow Model = Stokes

  include nonlinsys.sif
  include gcr.sif
  !include mumps.sif

  ! Convergence on timelevel (not required here)
  !---------------------------------------------
  !Relative Integration Order = -1
  Number of Integration Points = Integer 44 ! 21, 28, 44, 64, ...

  Save Viscosity = Logical True
  Save Slip = Logical True

! Some timing info
 Boundary Assembly Timing = Logical True
 Bulk Assembly Timing = Logical True
 Solver Timing = Logical True
 Linear System Timing = Logical True
 
 ! Calculate Loads = True
 ! Calculate Weights = True
 ! Calculate Boundary Weights = True

!  Exported Variable 1 = -dofs 4 Flow Solution Loads
!  Exported Variable 2 = Flow Solution Boundary Weights
End



Solver 4
  Exec Solver = "Before Timestep"
  Equation = "Normal vector"
  Procedure = "ElmerIceSolvers" "ComputeNormalSolver"
  Variable = -dofs 3 "Normal Vector"
  Optimize Bandwidth = Logical False
  ComputeAll = Logical False
End

Solver 5
   Exec Solver = "always"
   !Exec Solver = "Never"
   Equation = "Free Surface"
   Variable = String "Zs"
   Variable DOFs =  1
   ! needed for evaluating the contact pressure
   Exported Variable 1 = -dofs 1 "Zs Residual"
   ! needed for storing the initial shape (needed for updates)
   Exported Variable 2 = -dofs 1 "Ref Zs"
   Procedure = "FreeSurfaceSolver" "FreeSurfaceSolver"
  ! This would take the contrained points out of solution
  ! Use in serial run, only
 !  Before Linsolve = "EliminateDirichlet" "EliminateDirichlet"
   Linear System Solver = Iterative
   Linear System Max Iterations = 1500
   Linear System Iterative Method = BiCGStab
   Linear System Preconditioning = ILU1
   Linear System Convergence Tolerance = Real 1.0e-8
   !Linear System Abort Not Converged = False
   Linear System Residual Output = 1
   Nonlinear System Min Iterations = 2
   Nonlinear System Max Iterations = 100
   Nonlinear System Convergence Tolerance  = 1.0e-7
   !Nonlinear System Relaxation Factor = 0.60
   Steady State Convergence Tolerance = 1.0e-03
   Stabilization Method = Stabilized
  Stabilization Method = Bubbles
   ! Apply contact problem    
   Apply Dirichlet = Logical True

! How much the free surface is relaxed
 !Relaxation Factor = Real 0.90      
 
End

Solver 6
!Exec Solver = "Never"
  Equation = String "Homologous Temperature Equation"
  Procedure =  File "HeatSolveVec" "HeatSolver"
  ! Comment next line in parallel, as EliminateDirichlet does
  ! not work in parallel
  !------------------------------------------------------------
 ! Before Linsolve = "EliminateDirichlet" "EliminateDirichlet"
  Loop While Unconstrained Nodes = Logical True
  Variable = String "Temperature"
  Variable DOFs = 1
  Stabilization method = Stabilized
  Stabilize = True
  Apply Dirichlet = Logical True

  Optimize Bandwidth = Logical True
 ! Linear System Solver = "Direct"
 ! Linear System Direct Method = #directsolver
  Linear System Solver = "Iterative"
  Linear System Iterative Method = "GCR"
  Linear System GCR Restart = Integer 200
  Linear System Max Iterations = 500
  Linear System Convergence Tolerance = 1.0E-08
  Linear System Abort Not Converged = True
  Linear System Preconditioning = "ILU1"
  Linear System Residual Output = 250
  Nonlinear System Convergence Tolerance = 1.0E-06
  Nonlinear System Max Iterations = 50
  !Nonlinear System Relaxation Factor = Real 9.999E-01
  Steady State Convergence Tolerance = 1.0E-03
  ! the contact algorithm (aka Dirichlet algorithm)
  !-----------------------------------------------------
  Apply Limiter = Logical True
 ! Calculate Loads = Logical True
  !  Save Limiter = Logical True
  !Calculate Boundary Weights = Logical True
  ! those two variables are needed in order to store
  ! the relative or homologous temperature as well
  ! as the residual
  !-------------------------------------------------
  Exported Variable 1 = -dofs 1 "Relative Temperature"
 ! Exported Variable 2 = -dofs 1 "Temperature Loads"
 ! Exported Variable 3 = -dofs 1 "Temperature Boundary Weights"
  Exportede Variable 4 = String "Temperature Residual"
  Exported Variable 4 DOFs = 1
  Nonlinear Update Exported Variables = Logical True
  Update Exported Variables = Logical True
End

Solver 7
  Equation = DeformationalHeat
  Variable = W
  Variable DOFs = 1
  procedure = "ElmerIceSolvers" "DeformationalHeatSolver"
  Linear System Solver = direct
  Linear System direct Method = umfpack
End


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! EQUATION
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Equation 1
  Active Solvers(6) = 1 2 3 4 6 7
  Convection = Computed 
  Flow Solution Name = String "Flow Solution"
End

Equation 2
  Active Solvers(1)= 5
  Convection = Computed 
  Flow Solution Name = String "Flow Solution"
End

!



Boundary Condition 1
  ComputeNormal = Logical False
  Name = "sides"
  Target Boundaries(4) = 1 2 3 4 
  ! no slip
  !-------------------------
!Velocity 1 = 0
!Velocity 2 = 0
!Velocity 3 = 0
!Zs = Real $MinH
End


!! DON'T CHANGE ORDER OF NEXT 2 BC's!
!! They are automaticaly created in internal extrusion
!! bedrock:
Boundary Condition 2
  ComputeNormal = Logical True
  Name = "bedrock"
  Zb = Variable "Coordinate"
      Real MATC "0*tx(0)"
  Bottom Surface = Equals Zb
  ! No-slip velocity conditions
  Velocity 1 = Real 0.0
  Velocity 2 = Real 0.0
  Velocity 3 = Real 0.0
  Bedrock = Logical True
  Temperature Flux BC = Logical True

  Heat Flux = Real $0.050 * yearinsec * Pa2MPa

End

Boundary Condition 3
  ComputeNormal = Logical False
  Name = "surface"
  Body ID = 2
  Top Surface = Equals "Zs"
  Body ID = 2
  Surface = Logical True  

  Temperature = Variable "Coordinate"
     Real LUA "surfaceT(tx[0], tx[1])"

End

